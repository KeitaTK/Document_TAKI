<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# ArduPilot におけるAP_Observer拡張と周期実行の設計パターン

以下では、KeitaTK/UMEMOTO2 プロジェクト（Attに反映 ブランチ）における**AP_Observer**ライブラリの設計手法と、Copterクラスによる周期実行管理、さらにAC_AttitudeControlで補正値を利用する仕組みをまとめます。
URL: https://github.com/KeitaTK/UMEMOTO2/tree/Attに反映

***

## 1. ArduPilotのモジュール設計原則

1. **カプセル化とインターフェイス**
    - 各ライブラリは「自身の責務のみ」を実装し、他モジュールへの直接依存を避ける
    - 内部データはプライベート（private）にし、公開用メソッド（アクセサ）だけを public にする
    - 他モジュールと連携する際は、グローバルインスタンスかフレンド関数ではなく、明示的なアクセサ経由でやり取りする
2. **Wscriptによるビルド設定**
    - すべてのサブライブラリ共通のインクルード設定はトップレベル `wscript` で行う
    - 各ライブラリ固有の設定が必要な場合は `libraries/LibraryName/wscript` に記述する
3. **周期実行タスクの登録**
    - Copter クラスがスケジューラ（AP_Scheduler）にタスクを登録し、各周期で呼び出す
    - タスクメソッドは `void Copter::observer_update()` のように `observer.update()` を呼ぶだけに留め、ロジックはライブラリ側に実装

***

## 2. AP_Observerライブラリの設計と配置

- パス: `libraries/AP_Observer/`
- 構成ファイル:
    - `AP_Observer.h`：パラメータ定義とメソッド宣言のみ
    - `AP_Observer.cpp`：`update()` で力推定→クォータニオン補正を計算
    - `wscript`：ライブラリとして登録（依存関係不要に設定）


### 主な実装ポイント

```cpp
// AP_Observer.h
class AP_Observer {
public:
    void init() const;
    void update();  // センサ力から補正Quaternionを計算
    Quaternion get_correction_quaternion() const;
    bool is_correction_valid() const;
    uint32_t get_update_age_ms() const;
    static const AP_Param::GroupInfo var_info[];
private:
    Quaternion current_correction_quat;
    uint32_t last_update_ms;
    AP_Float _correction_gain;
    // 定数定義…
};
```

```cpp
// AP_Observer.cpp
#include "AP_Observer.h"
#include <AP_HAL/AP_HAL.h>
void AP_Observer::update() {
    // センサ力取得 → calculate_correction_from_force() → current_correction_quat 更新
    last_update_ms = AP_HAL::millis();
}
```

- **依存を持たせない**：`Copter.h` や制御クラスへの参照は一切なし。
- **パラメータ化**：`AP_Float _correction_gain;` を EEPROM パラメータとして管理。

***

## 3. Copterクラスによる周期実行管理

- パス: `ArduCopter/Copter.h`・`Copter.cpp`
- `Copter` はグローバルインスタンス `extern Copter copter;` を持ち、全体制御を司る


### observerタスク登録

```cpp
// Copter.cpp
#define SCHED_TASK(func, rate, time, prio) …
const AP_Scheduler::Task Copter::scheduler_tasks[] = {
    // ...
    SCHED_TASK(observer_update, 100, 50, 31),  // 100Hzでobserver.update()を呼ぶ
    // ...
};

void Copter::observer_update() {
    observer.update();
}
```

- **100Hz周期**：高周波での推力推定に適す
- **プライベートメンバ**：`AP_Observer observer;` は private だが、内部でだけ使うため問題なし

***

## 4. AC_AttitudeControlでの補正利用

- パス: `libraries/AC_AttitudeControl/AC_AttitudeControl.h`・`.cpp`
- 要件：`observer` が計算した補正を「姿勢目標」に反映


### ヘッダ側（依存最小化）

```cpp
#pragma once
#include <AP_Observer/AP_Observer.h>
class Copter;              // 前方宣言
extern Copter copter;      // グローバルインスタンス宣言

class AC_AttitudeControl {
    // ...
};
```

- `.h` では `#include "Copter.h"` はしない
- `class Copter; extern Copter copter;` だけを置く


### 実装側（Copter.hのインクルード）

```cpp
// AC_AttitudeControl.cpp
#include "AC_AttitudeControl.h"
#include "Copter.h"            // ここでのみ Copter を include
#include <AP_HAL/AP_HAL.h>
```


### 補正反映例

```cpp
void AC_AttitudeControl::update_attitude_target() {
    // 基本姿勢統合
    Quaternion update; update.from_axis_angle(_ang_vel_target_rads*_dt);
    _attitude_target *= update; _attitude_target.normalize();

    // Observer 補正
    AP_Observer& obs = copter.get_observer();
    Quaternion corr = obs.get_correction_quaternion();
    if (obs.is_correction_valid()) {
        _attitude_target = corr * _attitude_target;
        _attitude_target.normalize();
    }
}
```

- **アクセサ**：`Copter` に `AP_Observer& get_observer()` を public 追加してアクセス
- **private メンバ隠蔽**：`observer` 自体は private のまま

***

## 5. ビルド設定

- **トップレベル wscript**（`UMEMOTO2/wscript`）で共通インクルード設定

```python
cfg.env.prepend_value('INCLUDES', [
    cfg.srcnode.abspath() + '/libraries/',
    cfg.srcnode.abspath() + '/ArduCopter',  # 追加
])
```

これにより、すべてのライブラリ・モジュールで `#include "Copter.h"` が解決。

***

## 6. 一連の流れまとめ

1. **AP_Observer**：汎用ライブラリとして独立実装
2. **Copter**：`observer_update` タスクで定期的に update() を呼ぶ
3. **AC_AttitudeControl**：姿勢更新時に `copter.get_observer()` 経由で補正を取り込む
4. **wscript**：ビルド全体で必要なインクルードパスを設定

この設計パターンを踏襲すれば、新規ライブラリを追加して周期実行し、他モジュールから利用する機能を安全かつ拡張性高く実装できます。

